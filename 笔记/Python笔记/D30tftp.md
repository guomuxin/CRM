# D30tftp

## 一、UDP广播

- UDP广播:向网络中的所有主机的某个进程发送数据,tcp没有广播
  - 单播:点对点
  - 多播:一对多
  - 广播:一对所有
- 如果广播方给接收方每人发一份数据会卡顿,所以要借助交换机

## 二、集线器,交换机,路由器

- 集线器(HUB):一个网络中连接多个计算机或设备的连接设备,对网络进行集中管理的最小单元,集线器是一个共享设备,主要提供信号放大和中转的功能,把一个端口收到的信息转发给所有端口,效率低

  - 工作流程,集线器要给某个端口发送消息时,会先向所有端口发出消息,目标端口返回确认请求,其余端口返回拒绝请求,目标端口与发送端口建立连接,之后再进行传输,下一次还要发送数据时重复上述过程
  - 广播风暴:广播数据充斥网络,并占用大量带宽,导致业务不能正常进行

- 交换机(Switch):基于MAC识别,用于封装转发数据报,交换机可以学习记录MAC地址,并将其放在内部地址表中,通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址

  - 工作流程:当交换机要给之前没有通信过的端口发送数据时,工作流程和集线器一样,但是发送过数据之后就会生成地址对应表,当再次和该端口通信时就可以直接通信

  - 物理地址（实际地址）：由网络设备制造商生产时写在硬件内部

    IP地址与MAC地址在计算机里都是以二进制表示的，IP地址是32位的，而MAC地址则是48位的（6个字节）

    如：08:00:20:0A:8C:6D就是一个MAC地址，其中前3组16进制数08:00:20代表网络硬件制造商的编号，它由IEEE（电气与电子工程师协会）分配

    而后3组16进制数0A:8C:6D代表该制造商所制造的某个网络产品（如网卡）的系列号

    MAC地址在世界是惟一的

    （可以直接理解为网卡的序列号）

    通过IP地址、端口号、MAC地址   保证了数据的稳定传输

- 集线器和交换机的区别:

  - 集线器收到的消息会以广播形式发送出去
  - 交换机可以自动学习,与之前通信过的设备可以直接通信

- 路由器():连接不同网络,根据信道状况自动选择最佳路径传输数据

  - 作用:1.连接不同网络

    ​		 2.选择信息传输的线路

  - 同一个局域网当中的终端之间进行通讯的基础是处于同一个网段中，一个路由器至少有两个网卡，能够链接不同网段的网络使之可以通信

## 三、tftp(简单文件传输协议)

- TFTP（Trivial File Transfer Protocol,简单⽂件传输协议）是TCP/IP协议簇中的⼀个⽤来在客户端与服务器之间进⾏简单⽂件传输的协议

- 特点:
  - 简单
  - 占⽤资源⼩
  - 适合传递⼩⽂件
  - 适合在局域⽹进⾏传递
  - 端⼝号为69
  - 基于UDP实现
  
- Tftpd32:共享服务器(可以从本机共享文件)
  - browse：选择一个文件夹，确定给客户端文件时的搜索路径
  - 客户端：数据接收方
  - 服务器：数据发送方

- tftp流程:

  - 向服务器69端口发出读写请求
  - 服务器收到请求后,从随机端口发出大小为512字节数据包
  - 客户端每次收到数据包后就像服务器发送ACK确认包(像服务器发送数据包的端口发送,不可以向69端口发送)
  - 服务器如果没有在规定时间内没有收到ACK就重发数据包,收到就发送下一个数据包
  - 直到服务器发送的数据包大小小于516字节,发送结束

- TFTP格式要求:

  ![1571743158874](.\D30tftp.assets\1571743158874.png)
  
  读写请求:操作码1或2[1表示下载,2表示上传](2字节) + 文件名 + 0 + 模式(一般为"octet") + 0
  
  数据包: 操作码3(2字节) + 块编号(2字节) + 数据(最大512字节)
  
  ACK:操作码(2字节) + 快编号(2字节) 
  
  ERROR:操作码5(2字节) + 块编号(2字节) + 差错信息 + 0
  
  - 构造下载请求:
  
    ```
    
    import struct
    cmb_buf = struc.pack(格式,内容)
    假设文件名为test.jpg:下载请求数据:1test.jpg0octet0
    cmb_buf = struc.pack("!H8sb5sb",内容)
    ```
  
    - !表示按照网络传输要求的形式来组织数据(占位的格式)
    - H表示将后面的1替换成占位2个字节
    - 8s相当于8个s,即占8个字节
    - b占一个字节
  
- struct模块

  - struct模块可以按照指定格式将Python数据转换为字符串,该字符串为字节流

  - pack(格式,*值):按照给定格式将数据封装成字节流形式的字符串

    ```
    data = struct.pack(f"!H{len(filename.encode('gb2312'))}sb5sb", 1, filename.encode("gb2312"), 0, "octet".encode("gb2312"), 0)
    print(data)
    输出结果:
    b'\x00\x01a\x00octet\x00'
    ```

  - unpack(格式,):按照给定的格式(fmt)解析字节流string，返回解析出来的元组

    ```
    
    ca = struct.unpack("!HH",rec_data[0][:4])
    print(ca)
    输出结果:
    (3,1) #其中3为操作码,1为块编号
    ```

  - calcsize(fmt):计算给定的格式(fmt)占用多少字节的内存

    ```
    print(struct.calcsize("!H3sb"))
    输出结果:
    6
    ```

- 客户端(下载器实现):

  - 下载:从服务器上复制一个文件到本机

  - 下载的过程:

    - 在本地创建一个空文件（与要下载的文件同名）
    - 向里面写数据（接收到一点就向空文件里写一点）
    - 关闭（接受完所有数据关闭文件）

  - 完整实现:

    ```
    import struct
    from socket import *
    
    filename = input("请输入完整文件名:")
    addr = ("192.168.34.112", 69)
    s = socket(AF_INET, SOCK_DGRAM)
    #将数据打包
    data = struct.pack(f"!H{len(filename.encode('gb2312'))}sb5sb", 1, filename.encode("gb2312"), 0, "octet".encode("gb2312"), 0)
    #将下载请求发送给服务器的69端口
    s.sendto(data, addr)
    f = open(filename, "ab")
    
    while True:
    	#循环接收数据包
        rec_data = s.recvfrom(1024)
        #将收到的数据包解析,取出其中的操作码和块编号
        caozuo,num = struct.unpack("!HH",rec_data[0][:4])
        #真正的数据是从第五个字节开始的
        rel_data = rec_data[0][4:]
        #确认码构造
        ack = struct.pack("!HH", 4, num)
        #发送确认码
        s.sendto(ack, rec_data[1])
        #如果操作码为5说明报错,而客户端收到服务器发送的操作码不是5就是3
        if caozuo == 5:
            print("文件不存在")
            s.close()
            break
        else:
            f.write(rel_data)
        #如果数据大小小于512,说明这是最后一个数据包
        if len(rel_data) < 512:
            f.close()
            break
    ```

    